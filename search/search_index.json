{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Welcome to the documentation for the HULKs software. The section titles can be found in the bar at the top, inside a section the chapters will be listed on the left. Longer chapters will provide a table of contents on the right. TODO: the following paragraph needs to be reformulated We plan to release a \"final\" code release each year after RoboCup for which the documentation should be complete and correct. In addition to the yearly code release , we publish a weekly snapshot on a separate branch. Due to the frequent changes in the weekly branch, the documentation can be outdated at times. All our code is released under the terms of the GNU General Public License v3 . If you have questions that are not answered here, please file issues in our GitHub issue tracker so we can fix the documentation for everyone. As our team has limited resources, we don't expect to be able to give much in-depth support individually. Documentation Status Section Status Setup Incomplete Framework Incomplete, partially outdated Tooling Incomplete Operating System Missing Robotics Missing Workflow Missing","title":"Introduction"},{"location":"#overview","text":"Welcome to the documentation for the HULKs software. The section titles can be found in the bar at the top, inside a section the chapters will be listed on the left. Longer chapters will provide a table of contents on the right. TODO: the following paragraph needs to be reformulated We plan to release a \"final\" code release each year after RoboCup for which the documentation should be complete and correct. In addition to the yearly code release , we publish a weekly snapshot on a separate branch. Due to the frequent changes in the weekly branch, the documentation can be outdated at times. All our code is released under the terms of the GNU General Public License v3 . If you have questions that are not answered here, please file issues in our GitHub issue tracker so we can fix the documentation for everyone. As our team has limited resources, we don't expect to be able to give much in-depth support individually.","title":"Overview"},{"location":"#documentation-status","text":"Section Status Setup Incomplete Framework Incomplete, partially outdated Tooling Incomplete Operating System Missing Robotics Missing Workflow Missing","title":"Documentation Status"},{"location":"framework/communication/","text":"Communication TODO: Elaborate Communication Overview & Diagram Asynchronous Tasks Channels Database Subscriptions Notifications Subscription Management & Clients Extract subscribed types/images from databases and send them to clients Parameters Propagate changed parameters to cyclers Subscription Management & Clients (WebSocket) Protocol/(JSON) (De-)Serialization Acceptor Connection Setup (WebSocket handshake) Sender/Receiver Message Format","title":"Communication"},{"location":"framework/communication/#communication","text":"TODO: Elaborate Communication Overview & Diagram Asynchronous Tasks Channels Database Subscriptions Notifications Subscription Management & Clients Extract subscribed types/images from databases and send them to clients Parameters Propagate changed parameters to cyclers Subscription Management & Clients (WebSocket) Protocol/(JSON) (De-)Serialization Acceptor Connection Setup (WebSocket handshake) Sender/Receiver Message Format","title":"Communication"},{"location":"framework/configuration/","text":"Configuration TODO: Elaborate Configuration Configuration contains types Loaded from filesystem Location \"Overwriting\" & Robot \"Overwriting\"","title":"Configuration"},{"location":"framework/configuration/#configuration","text":"TODO: Elaborate Configuration Configuration contains types Loaded from filesystem Location \"Overwriting\" & Robot \"Overwriting\"","title":"Configuration"},{"location":"framework/cyclers/","text":"Cyclers A cycler in the HULKs robotic control software is a subcomponent that cycles modules. The name \"cycler\" comes from the characteristic that it contains a loop that iterates over incoming data and produces output data in each iteration. The cyclers call their internal cycle() function in each iteration. This cycle() function consists of three steps: Prepare : Wait for new data and prepare cycle Process : Run modules on the received data Finalize : E.g. send actuator commands or store data before starting the next cycle Multiple cyclers exist in the whole robotic control software. One of the main tasks of the framework is to allow cyclers to communicate with each other. For example, in the prepare step, data from other cyclers and communication is gathered. In addition, during the finalize step, data produced in the process step of this cycle may need to be communicated back to other cyclers. Cyclers are separated into the control cycler and multiple perception cyclers e.g. the vision cycler. Control Cycler The control cycler is the central cycler that runs in realtime synchronized to the LoLA interval (83 Hz). It receives sensor data from HULA/LoLA via the Hardware Interface and produces actuator output which is sent back to HULA/LoLA. The control cycler integrates data from all other perception cyclers in the filtering pipeline. Features for assisting in data integration in the filtering pipeline are explained in Filtering . The control cycler contains all robotics code that needs to be evaluated in each realtime cycle. In other words, all modules that are required to generate new outputs are included. Modules that can be excluded or need to much computation, for example the vision pipeline, are executed in their own perception cyclers. Perception Cyclers Beside the central control cycler, multiple perception cyclers exist which perceive data from the outside world and preprocess it. The outputs of each cycle are integrated in the control cycler to be respected for its realtime outputs. Since perception cyclers run in parallel to the control cycler and the control cycler is able to integrate historic data, perception cyclers may run at different cycle intervals. Perception cyclers normally wait on an event triggered from outside e.g. a new camera image or network message. The beginning of the processing is announced to the control cycler in the prepare step. In addition, perception cyclers acquire requested data from the control cycler. The perception cycle's output data is sent to the control cycler at the end of the cycle in the finalize step. More information about the interleaving of perceived data can be found in Filtering . The following perception cyclers exist: audio : Receives audio data from the Hardware Interface e.g. from NAO microphones spl_network : Waits for incoming network messages or outgoing message sending requests from other cyclers. Each cycle either preprocesses the incoming messages (e.g. by parsing) or sends the outgoing messages to the network. vision_top : Receives top camera images from the Hardware Interface and processes them to extract several features. vision_bottom : Similar to vision_top but receives camera images from the bottom camera.","title":"Cyclers"},{"location":"framework/cyclers/#cyclers","text":"A cycler in the HULKs robotic control software is a subcomponent that cycles modules. The name \"cycler\" comes from the characteristic that it contains a loop that iterates over incoming data and produces output data in each iteration. The cyclers call their internal cycle() function in each iteration. This cycle() function consists of three steps: Prepare : Wait for new data and prepare cycle Process : Run modules on the received data Finalize : E.g. send actuator commands or store data before starting the next cycle Multiple cyclers exist in the whole robotic control software. One of the main tasks of the framework is to allow cyclers to communicate with each other. For example, in the prepare step, data from other cyclers and communication is gathered. In addition, during the finalize step, data produced in the process step of this cycle may need to be communicated back to other cyclers. Cyclers are separated into the control cycler and multiple perception cyclers e.g. the vision cycler.","title":"Cyclers"},{"location":"framework/cyclers/#control-cycler","text":"The control cycler is the central cycler that runs in realtime synchronized to the LoLA interval (83 Hz). It receives sensor data from HULA/LoLA via the Hardware Interface and produces actuator output which is sent back to HULA/LoLA. The control cycler integrates data from all other perception cyclers in the filtering pipeline. Features for assisting in data integration in the filtering pipeline are explained in Filtering . The control cycler contains all robotics code that needs to be evaluated in each realtime cycle. In other words, all modules that are required to generate new outputs are included. Modules that can be excluded or need to much computation, for example the vision pipeline, are executed in their own perception cyclers.","title":"Control Cycler"},{"location":"framework/cyclers/#perception-cyclers","text":"Beside the central control cycler, multiple perception cyclers exist which perceive data from the outside world and preprocess it. The outputs of each cycle are integrated in the control cycler to be respected for its realtime outputs. Since perception cyclers run in parallel to the control cycler and the control cycler is able to integrate historic data, perception cyclers may run at different cycle intervals. Perception cyclers normally wait on an event triggered from outside e.g. a new camera image or network message. The beginning of the processing is announced to the control cycler in the prepare step. In addition, perception cyclers acquire requested data from the control cycler. The perception cycle's output data is sent to the control cycler at the end of the cycle in the finalize step. More information about the interleaving of perceived data can be found in Filtering . The following perception cyclers exist: audio : Receives audio data from the Hardware Interface e.g. from NAO microphones spl_network : Waits for incoming network messages or outgoing message sending requests from other cyclers. Each cycle either preprocesses the incoming messages (e.g. by parsing) or sends the outgoing messages to the network. vision_top : Receives top camera images from the Hardware Interface and processes them to extract several features. vision_bottom : Similar to vision_top but receives camera images from the bottom camera.","title":"Perception Cyclers"},{"location":"framework/databases_and_types/","text":"Databases & Types TODO: Elaborate TODO: crates/ ? TODO: Explain (de-)serialization of types (Example code!) Databases/Types Databases contain types (MainOutputs and AdditionalOutputs separated) Entries are always Options (-> Error Handling)","title":"Databases & Types"},{"location":"framework/databases_and_types/#databases-types","text":"TODO: Elaborate TODO: crates/ ? TODO: Explain (de-)serialization of types (Example code!) Databases/Types Databases contain types (MainOutputs and AdditionalOutputs separated) Entries are always Options (-> Error Handling)","title":"Databases &amp; Types"},{"location":"framework/directory_structure/","text":"Directory Structure TODO: Add crates directory TODO: Add twix TODO: Check if up-to-date The main code repository represents a monorepo containing many parts of the robotic control software and several tools. The directory structure is organized as follows: .github/ : GitHub Pull Request template and Actions workflow for the Continuous Integration the HULKs are using for development docs/ : This documentation etc/ : All additional files necessary when deploying the code to a robot configuration/ : Configuration files that are deployed to NAOs and are read during startup motions/ : Motion files that can be played back on a robot neural_networks/ : Neural network files for e.g. the ball detection poses/ and sounds/ : Legacy files (may be removed at some time) macros/ : Rust sub-crate providing e.g. the module macros module_attributes/ : Rust sub-crate providing macro attribute parsing for the module macros scripts/ : Legacy scripts and files (may be removed at some time) sdk/ : SDK download directory and version selection symlink spl_network/ : Rust sub-crate providing SPL message parsing including GameController messages src/ : Source code of the robotic control software audio/ : Audio cycler and all modules that belong to it behavior_simulator/ : Special runtime that is able to execute a subset of control modules for behavior simulation bin/ : Code for executables that can be built, e.g. nao and webots (these contain main() ) control/ : Control cycler and all modules that belong to it framework/ : Code regarding the framework containing e.g. filtering and thread communication primitives or the configuration hierarchy communication/ : Communication subcomponent containing the interface to the cyclers and all file system and socket I/O hardware/ : Hardware interface definition and several implementations for the build targets e.g. NAO and Webots, see Hardware Interface spl_network/ : SPL network cycler and all modules that belong to it types/ : Rust types that are used throughout the robotics code and framework vision/ : Vision cycler and all modules that belong to it tests/ : Additional data needed for tests of the robotic control software tools/ : Miscellaneous projects and tools more or less related to the code ci/ : Dockerfiles and scripts for the Continuous Integration the HULKs are using for development depp/ : Small tool to create a list of dependencies for Yocto Rust recipies (alternative to cargo-bitbake ) fanta/ : Debug client that can attach to communication and dump received data to standard output flora/ : Graphical debug client that can attach to communication and visualize the current state of the robot hula/ : Executable which runs on the NAO to provide the HULKs-level abstraction, a wrapper around LoLA, see Hardware Interface libPython/ : Legacy scripts and files (may be removed at some time) machine-learning/ : Tooling and training data for machine learning e.g. for ball detection pepsi/ : Mainly a tool for deploying and interacting with the NAO sprite/ : Behavior simulator frontend which can visualize the recorded behavior simulation TextToSpeech/ : Legacy files (may be removed at some time) uvcvideo/ : Rust sub-crate providing Linux USB Video Class driver support for NAO cameras webots/ : Root directory of webots simulation directory structure","title":"Directory Structure"},{"location":"framework/directory_structure/#directory-structure","text":"TODO: Add crates directory TODO: Add twix TODO: Check if up-to-date The main code repository represents a monorepo containing many parts of the robotic control software and several tools. The directory structure is organized as follows: .github/ : GitHub Pull Request template and Actions workflow for the Continuous Integration the HULKs are using for development docs/ : This documentation etc/ : All additional files necessary when deploying the code to a robot configuration/ : Configuration files that are deployed to NAOs and are read during startup motions/ : Motion files that can be played back on a robot neural_networks/ : Neural network files for e.g. the ball detection poses/ and sounds/ : Legacy files (may be removed at some time) macros/ : Rust sub-crate providing e.g. the module macros module_attributes/ : Rust sub-crate providing macro attribute parsing for the module macros scripts/ : Legacy scripts and files (may be removed at some time) sdk/ : SDK download directory and version selection symlink spl_network/ : Rust sub-crate providing SPL message parsing including GameController messages src/ : Source code of the robotic control software audio/ : Audio cycler and all modules that belong to it behavior_simulator/ : Special runtime that is able to execute a subset of control modules for behavior simulation bin/ : Code for executables that can be built, e.g. nao and webots (these contain main() ) control/ : Control cycler and all modules that belong to it framework/ : Code regarding the framework containing e.g. filtering and thread communication primitives or the configuration hierarchy communication/ : Communication subcomponent containing the interface to the cyclers and all file system and socket I/O hardware/ : Hardware interface definition and several implementations for the build targets e.g. NAO and Webots, see Hardware Interface spl_network/ : SPL network cycler and all modules that belong to it types/ : Rust types that are used throughout the robotics code and framework vision/ : Vision cycler and all modules that belong to it tests/ : Additional data needed for tests of the robotic control software tools/ : Miscellaneous projects and tools more or less related to the code ci/ : Dockerfiles and scripts for the Continuous Integration the HULKs are using for development depp/ : Small tool to create a list of dependencies for Yocto Rust recipies (alternative to cargo-bitbake ) fanta/ : Debug client that can attach to communication and dump received data to standard output flora/ : Graphical debug client that can attach to communication and visualize the current state of the robot hula/ : Executable which runs on the NAO to provide the HULKs-level abstraction, a wrapper around LoLA, see Hardware Interface libPython/ : Legacy scripts and files (may be removed at some time) machine-learning/ : Tooling and training data for machine learning e.g. for ball detection pepsi/ : Mainly a tool for deploying and interacting with the NAO sprite/ : Behavior simulator frontend which can visualize the recorded behavior simulation TextToSpeech/ : Legacy files (may be removed at some time) uvcvideo/ : Rust sub-crate providing Linux USB Video Class driver support for NAO cameras webots/ : Root directory of webots simulation directory structure","title":"Directory Structure"},{"location":"framework/error_handling/","text":"Error Handling TODO: Elaborate Error Handling 3 ways to handle errors Set a main output to none: Happens when the module is unable to generate this output (e.g. when inputs are not available or there was a temporary error inside of the module) Recoverable, expected to be resolved in the next cycle Return Err(...) from cycle() Unrecoverable, but framework is allowed to shutdown gracefully, expected that it will not improve in the next cycles/in the future Panic with e.g. panic!() or by unwrap() ing Unrecoverable, immediate shutdown, kernel will take down the whole process, there is no way to gracefully shutdown","title":"Error Handling"},{"location":"framework/error_handling/#error-handling","text":"TODO: Elaborate Error Handling 3 ways to handle errors Set a main output to none: Happens when the module is unable to generate this output (e.g. when inputs are not available or there was a temporary error inside of the module) Recoverable, expected to be resolved in the next cycle Return Err(...) from cycle() Unrecoverable, but framework is allowed to shutdown gracefully, expected that it will not improve in the next cycles/in the future Panic with e.g. panic!() or by unwrap() ing Unrecoverable, immediate shutdown, kernel will take down the whole process, there is no way to gracefully shutdown","title":"Error Handling"},{"location":"framework/filtering/","text":"Filtering TODO: Elaborate FutureQueue/Filtering Overview: Time diagram/plot Motivation: Filters need to have monotonic updates What needs a filter module to do in each cycle? Roll-back temporary measurements from last cycle Apply persistent measurements Temporarily apply temporary measurements FutureQueue (each Perception Cycler has one to communicate to Control) Producer announce finalize Consumer consume PersistentDatabases consumes from multiple FutureQueues and reorganizes data persistent vs. temporary PersistentInputs (Interface for the filter modules) persistent vs. temporary","title":"Filtering"},{"location":"framework/filtering/#filtering","text":"TODO: Elaborate FutureQueue/Filtering Overview: Time diagram/plot Motivation: Filters need to have monotonic updates What needs a filter module to do in each cycle? Roll-back temporary measurements from last cycle Apply persistent measurements Temporarily apply temporary measurements FutureQueue (each Perception Cycler has one to communicate to Control) Producer announce finalize Consumer consume PersistentDatabases consumes from multiple FutureQueues and reorganizes data persistent vs. temporary PersistentInputs (Interface for the filter modules) persistent vs. temporary","title":"Filtering"},{"location":"framework/hardware_interface/","text":"Hardware Interface TODO: Elaborate Hardware Interface Trait produce_sensor_data() NAO HardwareId retrieval (from HULA) LoLA/HAL/HULA Explain abbreviations Overview: State/Connection/Network/Component Diagram, DataFlow Model Socket Location and that it is a Unix Socket Proxy Message extraction and injection Message format LED animations Aliveness Network: Message format, UDP, multicast, JSON Service states produce_sensor_data() Cameras Video4Linux Buffering, Zero-copy (-> Cycler) Camera setup (registers) Audio ALSA ALSA configuration Later: Audio playback, Text-to-speech Webots HardwareId retrieval (robot name) Webots bindings produce_sensor_data() Image, audio transfer to different threads Simulation World Directory structure, symlink","title":"Hardware Interface"},{"location":"framework/hardware_interface/#hardware-interface","text":"TODO: Elaborate Hardware Interface Trait produce_sensor_data() NAO HardwareId retrieval (from HULA) LoLA/HAL/HULA Explain abbreviations Overview: State/Connection/Network/Component Diagram, DataFlow Model Socket Location and that it is a Unix Socket Proxy Message extraction and injection Message format LED animations Aliveness Network: Message format, UDP, multicast, JSON Service states produce_sensor_data() Cameras Video4Linux Buffering, Zero-copy (-> Cycler) Camera setup (registers) Audio ALSA ALSA configuration Later: Audio playback, Text-to-speech Webots HardwareId retrieval (robot name) Webots bindings produce_sensor_data() Image, audio transfer to different threads Simulation World Directory structure, symlink","title":"Hardware Interface"},{"location":"framework/logging/","text":"Logging TODO: Elaborate","title":"Logging"},{"location":"framework/logging/#logging","text":"TODO: Elaborate","title":"Logging"},{"location":"framework/macros/","text":"Macros TODO: Elaborate Macros What is a Rust macro? Gets a TokenStream as input, is able to transform it and outputs a new TokenStream Goal: Reduce code duplication, reduce manually-written code Module Module declaration #[module(...)] Declare a module Attached to impl Module {} Add struct CycleContext Contains inputs, additional outputs, etc. Add impl CycleContext { fn new(...) -> CycleContext {} } Add struct MainOutputs Contains main outputs Add impl MainOutputs { fn update(...) {} fn none() {} } Modify impl Module {} : Add fn run_cycle() {} Creates CycleContext and MainOutputs Call cycle() method of the module Inputs Input #[input(path, data_type, cycler, name)] Get data from this cycle within the current cycler Within control cycler: Historic Input #[historic_input(path, data_type, name)] Get historic data from control cycler Perception Input #[perception_input(path, data_type, cycler, name)] Get perception data from perception cyclers Persistent State #[persistent_state(path, data_type, name)] Share state between modules over multiple cycles Parameter #[parameter(data_type, name, path, on_changed)] Get configuration parameters from the configuration file/via Communication Outputs Main Output #[main_output(data_type, name)] Output for dependent modules, generated in every cycle Additional Output #[additional_output(path, data_type, name)] Optional output that can be enabled/requested from e.g. Communication require_some! TODO: required flag? Extracts data from cycle context and returns none for all main outputs if the input was none require_some!(...) => match ... { Some(...) => ..., None => return MainOutputs::none() } SerializeHierarchy Trait Mostly used by Communication for (de-)serialization Adds support for field paths Allows to (de-)serialize into/from field paths: fn serialize_hierarchy(field_path) , fn deserialize_hierarchy(field_path, data) Allows to check if a field paths exists Allows to generate a hierarchy object Implemented for all databases and configuration Macro #[derive(SerializeHierarchy)] Attached to structs Generates impl SerializeHierarchy for ... { ... } Iterates over all fields and delegates function calls to the fields 3rd-party macros: nalgebra::point or nalgebra::matrix Link to 3rd-party documentation","title":"Macros"},{"location":"framework/macros/#macros","text":"TODO: Elaborate Macros What is a Rust macro? Gets a TokenStream as input, is able to transform it and outputs a new TokenStream Goal: Reduce code duplication, reduce manually-written code Module Module declaration #[module(...)] Declare a module Attached to impl Module {} Add struct CycleContext Contains inputs, additional outputs, etc. Add impl CycleContext { fn new(...) -> CycleContext {} } Add struct MainOutputs Contains main outputs Add impl MainOutputs { fn update(...) {} fn none() {} } Modify impl Module {} : Add fn run_cycle() {} Creates CycleContext and MainOutputs Call cycle() method of the module Inputs Input #[input(path, data_type, cycler, name)] Get data from this cycle within the current cycler Within control cycler: Historic Input #[historic_input(path, data_type, name)] Get historic data from control cycler Perception Input #[perception_input(path, data_type, cycler, name)] Get perception data from perception cyclers Persistent State #[persistent_state(path, data_type, name)] Share state between modules over multiple cycles Parameter #[parameter(data_type, name, path, on_changed)] Get configuration parameters from the configuration file/via Communication Outputs Main Output #[main_output(data_type, name)] Output for dependent modules, generated in every cycle Additional Output #[additional_output(path, data_type, name)] Optional output that can be enabled/requested from e.g. Communication require_some! TODO: required flag? Extracts data from cycle context and returns none for all main outputs if the input was none require_some!(...) => match ... { Some(...) => ..., None => return MainOutputs::none() } SerializeHierarchy Trait Mostly used by Communication for (de-)serialization Adds support for field paths Allows to (de-)serialize into/from field paths: fn serialize_hierarchy(field_path) , fn deserialize_hierarchy(field_path, data) Allows to check if a field paths exists Allows to generate a hierarchy object Implemented for all databases and configuration Macro #[derive(SerializeHierarchy)] Attached to structs Generates impl SerializeHierarchy for ... { ... } Iterates over all fields and delegates function calls to the fields 3rd-party macros: nalgebra::point or nalgebra::matrix Link to 3rd-party documentation","title":"Macros"},{"location":"framework/modules/","text":"Modules Modules usually contain robotics code and are interchangeable components within cyclers. Each module is characterized by a cycle() function which is called in each cycle. The function gets module's inputs as parameters to the cycle() function and returns module's outputs from it. In addition, modules consist of a state which is perserved between cycles. Modules are normal Rust structs where the struct's fields represent the state and a method called cycle() in the impl of the module represents the cycle() function. This concept allows to write modules in a very Rusty way. A module may have multiple inputs of different kinds which can be annotated to the module. Here is an example module, but for more information see Macros : pub struct SolePressureFilter { // (1) left_sole_pressure : LowPassFilter < f32 > , right_sole_pressure : LowPassFilter < f32 > , } #[module(control)] // (2) #[parameter(path = low_pass_alpha, data_type = f32)] // (3) #[input(path = sensor_data, data_type = SensorData)] // (4) #[main_output(data_type = SolePressure)] // (5) impl SolePressureFilter {} // (6) impl SolePressureFilter { fn new ( context : NewContext ) -> anyhow :: Result < Self > { // (7) Ok ( Self { left_sole_pressure : LowPassFilter :: with_alpha ( 0.0 , * context . low_pass_alpha , // (8) ), right_sole_pressure : LowPassFilter :: with_alpha ( 0.0 , * context . low_pass_alpha , ), }) } fn cycle ( & mut self , context : CycleContext ) -> anyhow :: Result < MainOutputs > { // (9) let force_sensitive_resistors = & require_some ! ( context . sensor_data ). force_sensitive_resistors ; let left_sole_pressure = force_sensitive_resistors . left . sum (); self . left_sole_pressure . update ( left_sole_pressure ); let right_sole_pressure = force_sensitive_resistors . right . sum (); self . right_sole_pressure . update ( right_sole_pressure ); Ok ( MainOutputs { sole_pressure : Some ( SolePressure { left : self . left_sole_pressure . state (), right : self . right_sole_pressure . state (), }), }) } } Module's state Module declaration with module macro Configuration parameter of type f32 Input of type SensorData Output of type SolePressure Empty impl to improve usability of language servers and code linters. If the module declaration would be attached to the impl below, when writing incomplete code, the macros would produce errors. This happens a lot if writing module implementation code. Will be called at construction of the module Use declared configuration parameter. Since it is a reference, we need to dereference it with * . Will be called every cycle This module consumes the type SensorData as input and produces the output SolePressure . It has two state variables left_sole_pressure and right_sole_pressure . This specification of module inputs and outputs leads to a dependency graph which allows to topologically sort modules s.t. all dependencies are met before executing the module's cycle() . The build.rs file automatically sorts modules based on this graph.","title":"Modules"},{"location":"framework/modules/#modules","text":"Modules usually contain robotics code and are interchangeable components within cyclers. Each module is characterized by a cycle() function which is called in each cycle. The function gets module's inputs as parameters to the cycle() function and returns module's outputs from it. In addition, modules consist of a state which is perserved between cycles. Modules are normal Rust structs where the struct's fields represent the state and a method called cycle() in the impl of the module represents the cycle() function. This concept allows to write modules in a very Rusty way. A module may have multiple inputs of different kinds which can be annotated to the module. Here is an example module, but for more information see Macros : pub struct SolePressureFilter { // (1) left_sole_pressure : LowPassFilter < f32 > , right_sole_pressure : LowPassFilter < f32 > , } #[module(control)] // (2) #[parameter(path = low_pass_alpha, data_type = f32)] // (3) #[input(path = sensor_data, data_type = SensorData)] // (4) #[main_output(data_type = SolePressure)] // (5) impl SolePressureFilter {} // (6) impl SolePressureFilter { fn new ( context : NewContext ) -> anyhow :: Result < Self > { // (7) Ok ( Self { left_sole_pressure : LowPassFilter :: with_alpha ( 0.0 , * context . low_pass_alpha , // (8) ), right_sole_pressure : LowPassFilter :: with_alpha ( 0.0 , * context . low_pass_alpha , ), }) } fn cycle ( & mut self , context : CycleContext ) -> anyhow :: Result < MainOutputs > { // (9) let force_sensitive_resistors = & require_some ! ( context . sensor_data ). force_sensitive_resistors ; let left_sole_pressure = force_sensitive_resistors . left . sum (); self . left_sole_pressure . update ( left_sole_pressure ); let right_sole_pressure = force_sensitive_resistors . right . sum (); self . right_sole_pressure . update ( right_sole_pressure ); Ok ( MainOutputs { sole_pressure : Some ( SolePressure { left : self . left_sole_pressure . state (), right : self . right_sole_pressure . state (), }), }) } } Module's state Module declaration with module macro Configuration parameter of type f32 Input of type SensorData Output of type SolePressure Empty impl to improve usability of language servers and code linters. If the module declaration would be attached to the impl below, when writing incomplete code, the macros would produce errors. This happens a lot if writing module implementation code. Will be called at construction of the module Use declared configuration parameter. Since it is a reference, we need to dereference it with * . Will be called every cycle This module consumes the type SensorData as input and produces the output SolePressure . It has two state variables left_sole_pressure and right_sole_pressure . This specification of module inputs and outputs leads to a dependency graph which allows to topologically sort modules s.t. all dependencies are met before executing the module's cycle() . The build.rs file automatically sorts modules based on this graph.","title":"Modules"},{"location":"framework/overview/","text":"Overview TODO: Mention unit testing This section explains the framework of our NAO software. The chapters walk through various features in a top-down approach starting with a general overview. More advanced topics are covered later. Here is a short outline of the next chapters: Directory Structure : Explains the directory structure of the code repository Process EntryPoint : Starts the top-down approach from the main() function of the process Runtime : What does the runtime do to setup and inter-connect all subcomponents? Cyclers : How do cyclers run the robotics modules? Modules : What are modules and how are they implemented? Databases & Types : How can data be shared between cyclers and the framework? Configuration : How does the framework provide configuration parameters to modules? Communication : What is communication and how is it able to communicate between framework and modules? Hardware Interface : How is the hardware abstracted away for the different target platforms? Thread Communication : Which concepts and features exist to enable thread-safe communication between subcomponents? Filtering : How to interleave historic data in filters in an multi-threaded software? Macros : What macros exist that ease the development and how do they work? Error Handling : Which kinds of error handling concepts are supported and which to choose when? The framework provides the fundamentals needed to execute robotics specific code. It has a modular design to allow for convenient development and replacement of individual modules. The framework consists of four fundamental components: Runtime : Encapsulates all subcomponents by starting and initializing them Hardware Interface : Abstracts hardware away and is the interaction point for cyclers with the outside world Cyclers : Cycle through modules, process data from hardware and produce outputs (see e.g. control or vision_top ) Communication : Exchanges data between framework and other resources e.g. file system and network","title":"Overview"},{"location":"framework/overview/#overview","text":"TODO: Mention unit testing This section explains the framework of our NAO software. The chapters walk through various features in a top-down approach starting with a general overview. More advanced topics are covered later. Here is a short outline of the next chapters: Directory Structure : Explains the directory structure of the code repository Process EntryPoint : Starts the top-down approach from the main() function of the process Runtime : What does the runtime do to setup and inter-connect all subcomponents? Cyclers : How do cyclers run the robotics modules? Modules : What are modules and how are they implemented? Databases & Types : How can data be shared between cyclers and the framework? Configuration : How does the framework provide configuration parameters to modules? Communication : What is communication and how is it able to communicate between framework and modules? Hardware Interface : How is the hardware abstracted away for the different target platforms? Thread Communication : Which concepts and features exist to enable thread-safe communication between subcomponents? Filtering : How to interleave historic data in filters in an multi-threaded software? Macros : What macros exist that ease the development and how do they work? Error Handling : Which kinds of error handling concepts are supported and which to choose when? The framework provides the fundamentals needed to execute robotics specific code. It has a modular design to allow for convenient development and replacement of individual modules. The framework consists of four fundamental components: Runtime : Encapsulates all subcomponents by starting and initializing them Hardware Interface : Abstracts hardware away and is the interaction point for cyclers with the outside world Cyclers : Cycle through modules, process data from hardware and produce outputs (see e.g. control or vision_top ) Communication : Exchanges data between framework and other resources e.g. file system and network","title":"Overview"},{"location":"framework/process_entrypoint/","text":"Process Entrypoint The HULKs robotic control software can be compiled for multiple build targets e.g. NAO and Webots. Each build target results in a executable which is either executed directly on the NAO or on the development machine. All executables define a main() function as entrypoint for the robotic control software, see src/bin/ in the code. The following sections explain the first setup steps done in the main() function for the major build targets NAO and Webots. The final sections cover the behavior simulator entrypoint briefly. Shutdown and CancellationToken The main() functions for the NAO and Webots targets register shutdown handlers via the Rust crate ctrlc . These shutdown handlers react on the Linux signals SIGINT and SIGTERM to call CancellationToken::cancelled() which cancels the CancellationToken on signal receival. The CancellationToken is a synchronization primitive which is shared with the whole framework and robotics code to allow to shutdown all subcomponents from any location. Several places listen for the cancelled() event and terminate on cancellation. Beside cancelling the CancellationToken on Linux signals, error conditions within the robotic control software can trigger a cancellation as well. This concept allows to shutdown gracefully in any case of error or termination request. Hardware Interface & Runtime On NAO and in Webots the robotic control software needs access to the hardware or simulator interface. The hardware interface provides an abstract way to interact with the underlying backend. The main() function first initializes the hardware interface and then constructs the runtime with it. See Hardware Interface for more information about what the hardware interface initializes. At the end, the runtime is started. The main() function then waits for termination of the runtime which then concludes the process execution. Behavior Simulator The behavior simulator is a special build target which only initializes and starts a subset of the robotic control software. It is intended to be executed on the development machine. Cancellation and hardware interfaces are not needed and are therefore omitted from initialization in main() . Instead, the behavior simulator parses command line arguments and dispatches the behavior simulation.","title":"Process Entrypoint"},{"location":"framework/process_entrypoint/#process-entrypoint","text":"The HULKs robotic control software can be compiled for multiple build targets e.g. NAO and Webots. Each build target results in a executable which is either executed directly on the NAO or on the development machine. All executables define a main() function as entrypoint for the robotic control software, see src/bin/ in the code. The following sections explain the first setup steps done in the main() function for the major build targets NAO and Webots. The final sections cover the behavior simulator entrypoint briefly.","title":"Process Entrypoint"},{"location":"framework/process_entrypoint/#shutdown-and-cancellationtoken","text":"The main() functions for the NAO and Webots targets register shutdown handlers via the Rust crate ctrlc . These shutdown handlers react on the Linux signals SIGINT and SIGTERM to call CancellationToken::cancelled() which cancels the CancellationToken on signal receival. The CancellationToken is a synchronization primitive which is shared with the whole framework and robotics code to allow to shutdown all subcomponents from any location. Several places listen for the cancelled() event and terminate on cancellation. Beside cancelling the CancellationToken on Linux signals, error conditions within the robotic control software can trigger a cancellation as well. This concept allows to shutdown gracefully in any case of error or termination request.","title":"Shutdown and CancellationToken"},{"location":"framework/process_entrypoint/#hardware-interface-runtime","text":"On NAO and in Webots the robotic control software needs access to the hardware or simulator interface. The hardware interface provides an abstract way to interact with the underlying backend. The main() function first initializes the hardware interface and then constructs the runtime with it. See Hardware Interface for more information about what the hardware interface initializes. At the end, the runtime is started. The main() function then waits for termination of the runtime which then concludes the process execution.","title":"Hardware Interface &amp; Runtime"},{"location":"framework/process_entrypoint/#behavior-simulator","text":"The behavior simulator is a special build target which only initializes and starts a subset of the robotic control software. It is intended to be executed on the development machine. Cancellation and hardware interfaces are not needed and are therefore omitted from initialization in main() . Instead, the behavior simulator parses command line arguments and dispatches the behavior simulation.","title":"Behavior Simulator"},{"location":"framework/runtime/","text":"Runtime The runtime is the component in the robotic control software that encapsulates all subcomponents e.g. the hardware interface, cyclers, and communication. Here is a more detailed overview extending the drawing from Overview : This section and following ones will cover this drawing in more detail. Many dataflow connections are still left out to improve readability. The runtime is constructed with an already existing and initialized hardware interface. The runtime contains all subcomponents and therefore is in charge to construct them. Subcomponents require to be interconnected with each other. The runtime therefore creates all necessary communication channels and buffers that are shared between the subcomponents. More details on the connections between cyclers and communication are given in Communication . The communication subcomponent and each cycler are executed in separate threads which are started. The next section Cyclers talks more about the cyclers.","title":"Runtime"},{"location":"framework/runtime/#runtime","text":"The runtime is the component in the robotic control software that encapsulates all subcomponents e.g. the hardware interface, cyclers, and communication. Here is a more detailed overview extending the drawing from Overview : This section and following ones will cover this drawing in more detail. Many dataflow connections are still left out to improve readability. The runtime is constructed with an already existing and initialized hardware interface. The runtime contains all subcomponents and therefore is in charge to construct them. Subcomponents require to be interconnected with each other. The runtime therefore creates all necessary communication channels and buffers that are shared between the subcomponents. More details on the connections between cyclers and communication are given in Communication . The communication subcomponent and each cycler are executed in separate threads which are started. The next section Cyclers talks more about the cyclers.","title":"Runtime"},{"location":"framework/thread_communication/","text":"Thread Communication TODO: Elaborate Buffering/Thread Communication/Channels Tokio CancellationToken n-tuple Buffer Related to Triple Buffer Guarantees, Assumptions Tokio channels Channel flow diagram (mostly Cycler<->Cycler and Cycler<->Communication)","title":"Thread Communication"},{"location":"framework/thread_communication/#thread-communication","text":"TODO: Elaborate Buffering/Thread Communication/Channels Tokio CancellationToken n-tuple Buffer Related to Triple Buffer Guarantees, Assumptions Tokio channels Channel flow diagram (mostly Cycler<->Cycler and Cycler<->Communication)","title":"Thread Communication"},{"location":"operating_system/home_directory/","text":"Home Directory The home directory ( /home/nao/ ) is overlayed with a mount to the /data partition (see Partitioning ). When flashing the robot and uploading the hulk binary, the home directory structure looks as follows: . | -- hulk | | -- bin | | ` -- hulk | | -- etc | | | -- configuration | | | ` -- *.json | | | -- motions | | | ` -- *.motion2 | | | -- neural_networks | | | ` -- *.hdf5 | | | -- poses | | | ` -- *.pose | | ` -- sounds | | ` -- *.ogg | ` -- logs | | -- hulk-1667906932.err | | -- hulk-1667906932.out | | -- hulk.err -> /home/nao/hulk/logs/hulk-1667906932.err | ` -- hulk.out -> /home/nao/hulk/logs/hulk-1667906932.out ` -- robocup.conf The ./robocup.conf file is required to start the LoLA service in robocupper mode. All files related to the hulk service and binaries are stored in the subdirectory hulk and mirrors the files of the directory structure of the development repository ( Directory Structure ).","title":"Home Directory"},{"location":"operating_system/home_directory/#home-directory","text":"The home directory ( /home/nao/ ) is overlayed with a mount to the /data partition (see Partitioning ). When flashing the robot and uploading the hulk binary, the home directory structure looks as follows: . | -- hulk | | -- bin | | ` -- hulk | | -- etc | | | -- configuration | | | ` -- *.json | | | -- motions | | | ` -- *.motion2 | | | -- neural_networks | | | ` -- *.hdf5 | | | -- poses | | | ` -- *.pose | | ` -- sounds | | ` -- *.ogg | ` -- logs | | -- hulk-1667906932.err | | -- hulk-1667906932.out | | -- hulk.err -> /home/nao/hulk/logs/hulk-1667906932.err | ` -- hulk.out -> /home/nao/hulk/logs/hulk-1667906932.out ` -- robocup.conf The ./robocup.conf file is required to start the LoLA service in robocupper mode. All files related to the hulk service and binaries are stored in the subdirectory hulk and mirrors the files of the directory structure of the development repository ( Directory Structure ).","title":"Home Directory"},{"location":"operating_system/hula/","text":"HULA TODO","title":"HULA"},{"location":"operating_system/hula/#hula","text":"TODO","title":"HULA"},{"location":"operating_system/linux/","text":"Linux The Nao uses a Linux 5.4 real time kernel for intel processors ( linux-intel/preempt-rt ). Most of the kernel configuration is done by the meta-intel layer for yocto. Special modifications for the Nao robot are contained in the meta-nao layer and mainly consist of patches and kernel modules by aldebaran for chestboard communication.","title":"Linux"},{"location":"operating_system/linux/#linux","text":"The Nao uses a Linux 5.4 real time kernel for intel processors ( linux-intel/preempt-rt ). Most of the kernel configuration is done by the meta-intel layer for yocto. Special modifications for the Nao robot are contained in the meta-nao layer and mainly consist of patches and kernel modules by aldebaran for chestboard communication.","title":"Linux"},{"location":"operating_system/overview/","text":"Overview TODOs: Chapter introduction HULA Outline Partitioning Home Directory Linux WiFi HULA","title":"Overview"},{"location":"operating_system/overview/#overview","text":"TODOs: Chapter introduction HULA","title":"Overview"},{"location":"operating_system/overview/#outline","text":"Partitioning Home Directory Linux WiFi HULA","title":"Outline"},{"location":"operating_system/partitioning/","text":"Partitioning The Nao uses a single flash storage device for main storage purposes. After a successfully flashing the robot with the HULKs OS, this storage device is recogniced as /dev/mmcblk1 . The device counts 4 separate partitions. NAME SIZE MOUNTPOINTS mmcblk1 29 .1G | -mmcblk1p1 128M /media/internal | -mmcblk1p2 64M | -mmcblk1p3 3 .8G / ` -mmcblk1p4 25 .1G /data Softbank partition mmcblk1p1 The first partition is called 'internal' and is used by softbank binaries and during the flashing. The partition is mounted by default at /media/internal and is required to be mounted when using LoLA or HAL. During standard use, this partition is not accessed by HULKs binaries. Softbank uses this partition to store general information about the robot, such as IDs. The aldebaran script /opt/aldebaran/head_id for example uses the file /media/internal/DeviceHeadInternalGeode.xml to query the id of the head. EFI partition mmcblk1p2 The second partition is the EFI boot partition and not mounted by default. To inspect the EFI files mount this partition: sudo su mount /dev/mmcblk1p2 /mnt/ # inspect files at /mnt/ Root partition mmcblk1p3 The third partition is the root partition. This partition is created and managed by the yocto configuration and usually not inteded to be modified at runtime. Data partition mmcblk1p4 The fourth and last partition is for runtime data storage. It is mounted to /data by default. When first booting up the system, the two system units data-format and data-skeleton are responsible of setting up the partition and directory structure. The data-format unit is run once before mounting the partition to create a new filesystem and disables itself afterwards. The data-skeleton unit is run every startup and provides a directory structure for following overlay mounts. Home directory /home/nao The home directory is used for custom user code and also for storing and executing the hulk binary. It is an overlay mount specified in the /etc/fstab : [ ... ] overlay /home/nao overlay lowerdir = /home/nao,upperdir = /data/home/nao,workdir = /data/.work-home-nao 0 0 [ ... ]","title":"Partitioning"},{"location":"operating_system/partitioning/#partitioning","text":"The Nao uses a single flash storage device for main storage purposes. After a successfully flashing the robot with the HULKs OS, this storage device is recogniced as /dev/mmcblk1 . The device counts 4 separate partitions. NAME SIZE MOUNTPOINTS mmcblk1 29 .1G | -mmcblk1p1 128M /media/internal | -mmcblk1p2 64M | -mmcblk1p3 3 .8G / ` -mmcblk1p4 25 .1G /data","title":"Partitioning"},{"location":"operating_system/partitioning/#softbank-partition-mmcblk1p1","text":"The first partition is called 'internal' and is used by softbank binaries and during the flashing. The partition is mounted by default at /media/internal and is required to be mounted when using LoLA or HAL. During standard use, this partition is not accessed by HULKs binaries. Softbank uses this partition to store general information about the robot, such as IDs. The aldebaran script /opt/aldebaran/head_id for example uses the file /media/internal/DeviceHeadInternalGeode.xml to query the id of the head.","title":"Softbank partition mmcblk1p1"},{"location":"operating_system/partitioning/#efi-partition-mmcblk1p2","text":"The second partition is the EFI boot partition and not mounted by default. To inspect the EFI files mount this partition: sudo su mount /dev/mmcblk1p2 /mnt/ # inspect files at /mnt/","title":"EFI partition mmcblk1p2"},{"location":"operating_system/partitioning/#root-partition-mmcblk1p3","text":"The third partition is the root partition. This partition is created and managed by the yocto configuration and usually not inteded to be modified at runtime.","title":"Root partition mmcblk1p3"},{"location":"operating_system/partitioning/#data-partition-mmcblk1p4","text":"The fourth and last partition is for runtime data storage. It is mounted to /data by default. When first booting up the system, the two system units data-format and data-skeleton are responsible of setting up the partition and directory structure. The data-format unit is run once before mounting the partition to create a new filesystem and disables itself afterwards. The data-skeleton unit is run every startup and provides a directory structure for following overlay mounts.","title":"Data partition mmcblk1p4"},{"location":"operating_system/partitioning/#home-directory-homenao","text":"The home directory is used for custom user code and also for storing and executing the hulk binary. It is an overlay mount specified in the /etc/fstab : [ ... ] overlay /home/nao overlay lowerdir = /home/nao,upperdir = /data/home/nao,workdir = /data/.work-home-nao 0 0 [ ... ]","title":"Home directory /home/nao"},{"location":"operating_system/wifi/","text":"WiFi The WiFi is supplied by a Qualcomm Atheros AR9462 and configured via the iNet Wireless Daemon (iwd) . For more information on iwd visit their documentation. iwd Configuration The iwd service can be manually configured using the command line interface tool iwctl . For persistent configuration iwd stores *.psk files for every known SSID at /var/lib/iwd/ . The yocto distribution installs those *.psk files for the network SSIDs SPL_A to SPL_F . [ Security ] Passphrase = Nao?!Nao?! [ Settings ] AutoConnect = false Automatic connection is disabled to prevent the Nao to connect to any SPL network in range. If iwd was tasked to connect to a network once, it tries to reconnect to that same SSID until the daemon is instructed to disconnect. The iwd is also able configure IP settings and run DHCP. This is called Network Configuration and disabled via the /etc/iwd/main.conf . IP configuration is and done by systemd-networkd . [ General ] EnableNetworkConfiguration = false IP Configuration The Nao's IP address is derived from the robots id number in the ../setup/nao_image_and_sdk.md . This follows the pattern 10.{Interface}.{TeamNumber}.{NaoNumber} . For the robot 22 of team HULKs this is 10.0.24.22 on the wireless interface and 10.1.24.22 on the wired interface. Responsible for the configuration is the systemd unit network-config running the /usr/sbin/configure_network script once per boot. This script is calculating the IP configuration based on the entries in the /etc/id_map.json and generates systemd network configuration files at /etc/systemd/network/80-wlan.network and /etc/systemd/network/80-wired.network .","title":"WiFi"},{"location":"operating_system/wifi/#wifi","text":"The WiFi is supplied by a Qualcomm Atheros AR9462 and configured via the iNet Wireless Daemon (iwd) . For more information on iwd visit their documentation.","title":"WiFi"},{"location":"operating_system/wifi/#iwd-configuration","text":"The iwd service can be manually configured using the command line interface tool iwctl . For persistent configuration iwd stores *.psk files for every known SSID at /var/lib/iwd/ . The yocto distribution installs those *.psk files for the network SSIDs SPL_A to SPL_F . [ Security ] Passphrase = Nao?!Nao?! [ Settings ] AutoConnect = false Automatic connection is disabled to prevent the Nao to connect to any SPL network in range. If iwd was tasked to connect to a network once, it tries to reconnect to that same SSID until the daemon is instructed to disconnect. The iwd is also able configure IP settings and run DHCP. This is called Network Configuration and disabled via the /etc/iwd/main.conf . IP configuration is and done by systemd-networkd . [ General ] EnableNetworkConfiguration = false","title":"iwd Configuration"},{"location":"operating_system/wifi/#ip-configuration","text":"The Nao's IP address is derived from the robots id number in the ../setup/nao_image_and_sdk.md . This follows the pattern 10.{Interface}.{TeamNumber}.{NaoNumber} . For the robot 22 of team HULKs this is 10.0.24.22 on the wireless interface and 10.1.24.22 on the wired interface. Responsible for the configuration is the systemd unit network-config running the /usr/sbin/configure_network script once per boot. This script is calculating the IP configuration based on the entries in the /etc/id_map.json and generates systemd network configuration files at /etc/systemd/network/80-wlan.network and /etc/systemd/network/80-wired.network .","title":"IP Configuration"},{"location":"robotics/overview/","text":"Overview TODO: Elaborate Perception Filters SPL Network (GameController communication, Team communication) Vision Whistle Detection/Audio Behavior World state -> Actions -> MotionCommand Motion Step planning Walking Kicking ...","title":"Overview"},{"location":"robotics/overview/#overview","text":"TODO: Elaborate","title":"Overview"},{"location":"robotics/overview/#perception","text":"Filters SPL Network (GameController communication, Team communication) Vision Whistle Detection/Audio","title":"Perception"},{"location":"robotics/overview/#behavior","text":"World state -> Actions -> MotionCommand","title":"Behavior"},{"location":"robotics/overview/#motion","text":"Step planning Walking Kicking ...","title":"Motion"},{"location":"robotics/behavior/behavior/","text":"","title":"Behavior"},{"location":"robotics/motion/kicking/","text":"","title":"Kicking"},{"location":"robotics/motion/motion_files/","text":"Motion Files","title":"Motion Files"},{"location":"robotics/motion/motion_files/#motion-files","text":"","title":"Motion Files"},{"location":"robotics/motion/step_planning/","text":"","title":"Step planning"},{"location":"robotics/motion/walking/","text":"","title":"Walking"},{"location":"robotics/perception/audio/","text":"","title":"Audio"},{"location":"robotics/perception/filters/","text":"","title":"Filters"},{"location":"robotics/perception/spl_network/","text":"","title":"SPL Network"},{"location":"robotics/perception/vision/","text":"Vision TODO: Mention all modules or just the important ones? Modules of questionable importance: Field color detection Camera matrix provider TODO: Add images The vision cycler runs twice in two separate threads to process the images from the top and bottom camera in parallel. Image resolution is determined by the hardware interface, but is currently set to 640x480 pixels for performance reasons. Most of the vision pipeline happens on a segmented version of the image for the same reason. Each cycler instance waits for the hardware interface to deliver it's respective camera image and then begins executing the modules listed below. Camera Matrix Provider Field Color Detection Image Segmenter The first major module in the vision pipeline is the image segmenter. It iterates through the image and merges vertically adjacent pixels that are similar. This reduces the amount of elements subsequent modules have to process. Instead of 480 pixels, each vertical scan line is reduced to just a dozen or so segments, depending on the image. A stride can be set to only generate scanlines for every n-th pixel column. Furthermore, segments which are above the horizon or overlap the robots limbs are discarded, resulting in a sparse image. Each segment contains it's location, color, edge types, and a pre-calculated classification of field color intensity. Field Border Detection Estimates the location of the upper field border in the image by finding the first pixels from the top that are roughly field-colored and fitting a line through them. Segment Filter The image segments are further reduced by removing all segments that are considered field color to only preserve relevant features. Segments above the field border are also removed. Line Detection Using the filtered segments, field lines are detected by looking for white segments of appropriate length. For each segment the brightness gradient at each end is calculated using the Sobel operator . The segment is discarded if the gradients are not sufficiently steep upwards and downwards, i.e. the segment borders do not lie on opposite flanks of a field line. The center of each remaining segment is then used in a RANSAC line fitting algorithm. Found lines are projected onto the ground and then checked against those found previously to see if they are either parallel or orthogonal to each other. TODO: Why check parallelism and orthogonality? What do we do with this information? Perspective Grid Candidate Provider This module generates candidates for the Ball Detection . Starting from the bottom of the image, rows of circles are generated where the circle size matches the projected ball in the row's center. Candidates are only generated when the center of at least one filtered segment is inside the candidate circle's bounding box. Ball Detection For each perspective grid candidate a series of artifical neural networks is used to determine whether it contains a ball as well as the balls location and radius. First, a slightly larger sample centered around the candidate is extracted from the raw image. This sample is scaled up or down to 32x32 pixels, regardless of the size in the raw image. The first neural network to run on the image is called the \"preclassifier\", which is a small but cheap model to quickly filter out candidates that are clearly not a ball. If the preclassifier claims to have found a ball, a larger and more accurate network, the \"classifier\", is executed to decide whether the candidate contains a ball or not. Once the classifier finds a ball, a third neural network, the \"positioner\", is used to determine the location and size of the ball within the sample. These values are then transformed back into the coordinate frame of the image and then projected onto the field to determine the final location of the detected ball. TODO: Clustering TODO: Implement this view in twix and update screenshot Debug view showing: blue circle: candidates from the perspective grid green circle: positioner network output white circle: clustered ball location red circle: current ball model, see filters black text: preclassifier confidence Robot Detection Warning: This module is still work in progress. For detecting robots, a clustering algorithm runs through each vertical scanline of the filtered image segments, ignoring segments that have been previously used by the ball detection or line detection. The last (bottom most) cluster in each scanline is then projected to the ground and clustered first using the score-weighted distance and then again using cones. TODO: What does this mean? Why do we do this?","title":"Vision"},{"location":"robotics/perception/vision/#vision","text":"TODO: Mention all modules or just the important ones? Modules of questionable importance: Field color detection Camera matrix provider TODO: Add images The vision cycler runs twice in two separate threads to process the images from the top and bottom camera in parallel. Image resolution is determined by the hardware interface, but is currently set to 640x480 pixels for performance reasons. Most of the vision pipeline happens on a segmented version of the image for the same reason. Each cycler instance waits for the hardware interface to deliver it's respective camera image and then begins executing the modules listed below.","title":"Vision"},{"location":"robotics/perception/vision/#camera-matrix-provider","text":"","title":"Camera Matrix Provider"},{"location":"robotics/perception/vision/#field-color-detection","text":"","title":"Field Color Detection"},{"location":"robotics/perception/vision/#image-segmenter","text":"The first major module in the vision pipeline is the image segmenter. It iterates through the image and merges vertically adjacent pixels that are similar. This reduces the amount of elements subsequent modules have to process. Instead of 480 pixels, each vertical scan line is reduced to just a dozen or so segments, depending on the image. A stride can be set to only generate scanlines for every n-th pixel column. Furthermore, segments which are above the horizon or overlap the robots limbs are discarded, resulting in a sparse image. Each segment contains it's location, color, edge types, and a pre-calculated classification of field color intensity.","title":"Image Segmenter"},{"location":"robotics/perception/vision/#field-border-detection","text":"Estimates the location of the upper field border in the image by finding the first pixels from the top that are roughly field-colored and fitting a line through them.","title":"Field Border Detection"},{"location":"robotics/perception/vision/#segment-filter","text":"The image segments are further reduced by removing all segments that are considered field color to only preserve relevant features. Segments above the field border are also removed.","title":"Segment Filter"},{"location":"robotics/perception/vision/#line-detection","text":"Using the filtered segments, field lines are detected by looking for white segments of appropriate length. For each segment the brightness gradient at each end is calculated using the Sobel operator . The segment is discarded if the gradients are not sufficiently steep upwards and downwards, i.e. the segment borders do not lie on opposite flanks of a field line. The center of each remaining segment is then used in a RANSAC line fitting algorithm. Found lines are projected onto the ground and then checked against those found previously to see if they are either parallel or orthogonal to each other. TODO: Why check parallelism and orthogonality? What do we do with this information?","title":"Line Detection"},{"location":"robotics/perception/vision/#perspective-grid-candidate-provider","text":"This module generates candidates for the Ball Detection . Starting from the bottom of the image, rows of circles are generated where the circle size matches the projected ball in the row's center. Candidates are only generated when the center of at least one filtered segment is inside the candidate circle's bounding box.","title":"Perspective Grid Candidate Provider"},{"location":"robotics/perception/vision/#ball-detection","text":"For each perspective grid candidate a series of artifical neural networks is used to determine whether it contains a ball as well as the balls location and radius. First, a slightly larger sample centered around the candidate is extracted from the raw image. This sample is scaled up or down to 32x32 pixels, regardless of the size in the raw image. The first neural network to run on the image is called the \"preclassifier\", which is a small but cheap model to quickly filter out candidates that are clearly not a ball. If the preclassifier claims to have found a ball, a larger and more accurate network, the \"classifier\", is executed to decide whether the candidate contains a ball or not. Once the classifier finds a ball, a third neural network, the \"positioner\", is used to determine the location and size of the ball within the sample. These values are then transformed back into the coordinate frame of the image and then projected onto the field to determine the final location of the detected ball. TODO: Clustering TODO: Implement this view in twix and update screenshot Debug view showing: blue circle: candidates from the perspective grid green circle: positioner network output white circle: clustered ball location red circle: current ball model, see filters black text: preclassifier confidence","title":"Ball Detection"},{"location":"robotics/perception/vision/#robot-detection","text":"Warning: This module is still work in progress. For detecting robots, a clustering algorithm runs through each vertical scanline of the filtered image segments, ignoring segments that have been previously used by the ball detection or line detection. The last (bottom most) cluster in each scanline is then projected to the ground and clustered first using the score-weighted distance and then again using cones. TODO: What does this mean? Why do we do this?","title":"Robot Detection"},{"location":"setup/main_setup/","text":"Main Setup and Compiling for Webots This section will guide you through the installation of dependencies and compiling the code for the Webots simulator. We recommend using Arch Linux or one of it's derivatives such as Manjaro . Installing Dependencies Some packages are required to be installed before you can compile and run our code. Use your distribution's package manager to install the following dependencies: Arch Linux/Manjaro Ubuntu Install dependencies yay -S git git-lfs base-devel rustup rsync cmake clang hdf5 python webots yay is used because webots is an AUR package. Optionally substitute yay with your favorite AUR helper. Install rust toolchain rustup default stable Install dependencies sudo apt install git git-lfs build-essential libssl-dev pkg-config libclang-dev rsync cmake libhdf5-dev python Install Webots sudo snap install webots Install rust toolchain Visit https://rustup.rs/ for up to date instructions. Acquiring the code HULKs Members Non HULKs Members If you are a HULKs member, you should have access to our HULKs/nao repository on GitHub: git clone git@github.com:HULKs/nao If you are not a member of the HULKs club, use our code release at HULKs/CodeRelease . git clone git@github.com:HULKs/HULKsCodeRelease Compiling for Webots In the root of our repository is a script called pepsi . See pepsi for details. Simply execute the build command in the repository root to build a binary for use with Webots. This will first build the pepsi binary and then start the build process. ./pepsi build Running Webots Once the compilation step is complete, open webots and load the scene at webots/worlds/penalized.wbt from the repository.","title":"Main Setup & Webots"},{"location":"setup/main_setup/#main-setup-and-compiling-for-webots","text":"This section will guide you through the installation of dependencies and compiling the code for the Webots simulator. We recommend using Arch Linux or one of it's derivatives such as Manjaro .","title":"Main Setup and Compiling for Webots"},{"location":"setup/main_setup/#installing-dependencies","text":"Some packages are required to be installed before you can compile and run our code. Use your distribution's package manager to install the following dependencies: Arch Linux/Manjaro Ubuntu Install dependencies yay -S git git-lfs base-devel rustup rsync cmake clang hdf5 python webots yay is used because webots is an AUR package. Optionally substitute yay with your favorite AUR helper. Install rust toolchain rustup default stable Install dependencies sudo apt install git git-lfs build-essential libssl-dev pkg-config libclang-dev rsync cmake libhdf5-dev python Install Webots sudo snap install webots Install rust toolchain Visit https://rustup.rs/ for up to date instructions.","title":"Installing Dependencies"},{"location":"setup/main_setup/#acquiring-the-code","text":"HULKs Members Non HULKs Members If you are a HULKs member, you should have access to our HULKs/nao repository on GitHub: git clone git@github.com:HULKs/nao If you are not a member of the HULKs club, use our code release at HULKs/CodeRelease . git clone git@github.com:HULKs/HULKsCodeRelease","title":"Acquiring the code"},{"location":"setup/main_setup/#compiling-for-webots","text":"In the root of our repository is a script called pepsi . See pepsi for details. Simply execute the build command in the repository root to build a binary for use with Webots. This will first build the pepsi binary and then start the build process. ./pepsi build","title":"Compiling for Webots"},{"location":"setup/main_setup/#running-webots","text":"Once the compilation step is complete, open webots and load the scene at webots/worlds/penalized.wbt from the repository.","title":"Running Webots"},{"location":"setup/nao_image_and_sdk/","text":"NAO Image & SDK TODO: decide whether to backtick all \"meta-nao\", \"meta-hulks\", \"kas\", \"BitBake\" names TODO: \"code release\" or \"code-release\" or \"coderelease\"? TODO: Set up id map json first TODO: Change team number in meta-hulks The HULKs use the Yocto Project for creating flashable OPN images for the NAO and a corresponding software development kit (SDK) for local development targeting the NAO. The SDK contains a full cross-compilation toolchain that is self-contained and can be easily used on development machines. Use an Existing Yocto SDK with the HULKs Code HULKs Members Non HULKs Members HULKs members can just use the Pepsi tool (TODO: link to Pepsi) to compile and upload to a booted NAO. This needs to be done in the lab or with VPN access to the BigHULK. Within the HULKs repository, use the following command to e.g. upload to NAO 42: ./pepsi upload 42 You will be asked to install the SDK during the compilation process. Just choose the defaults if unsure or ask your fellow HULK. Non HULKs members need to copy the Yocto SDK to the local downloads folder to prevent the Pepsi tool (TODO: link to Pepsi) from downloading it during compilation. For instructions on how to build the image and SDK refer to the section Image & SDK Creation . mkdir -p sdk/downloads/ cp .../HULKs-OS-toolchain- [ ... ] .sh sdk/downloads/ ./pepsi upload 42 You will be asked to install the SDK during the compilation process. Just choose the defaults if unsure. Image & SDK Creation The Yocto Project leverages BitBake as task execution engine and offers an abstraction layer to modify and extend existing build configurations. Combined with OpenEmbedded , the entire worktree is structured in several layers (the HULKs use the meta-nao and meta-hulks layers). Setup of the Working Directory For creating the image and SDK, make sure there is at least 100 GB empty disk space available. Start by cloning the code (if not done before) and setting up a Yocto working directory. This working directory will contain the layers HULKs/meta-nao and meta-hulks, a script for running BitBake commands, and the HULKs nao repository. It will be called yocto . The new yocto working directory must have at least 100 GB of empty space available and should not be part of a Git repository. mkdir yocto/ cd yocto/ HULKs Members Non HULKs Members HULKs members need the HULKs/nao repository, and the HULKs/meta-nao and HULKs/meta-hulks layer. The rest should already be set up. # working directory is still `yocto` git clone git@github.com:HULKs/nao git clone git@github.com:HULKs/meta-nao git clone git@github.com:HULKs/meta-hulks Non HULKs members need the HULKs/meta-nao layer and the meta-hulks layer from HULKs/CodeRelease (in the subdirectory yocto/meta-hulks ). # working directory is still `yocto` git clone git@github.com:HULKs/HULKsCodeRelease mv HULKsCodeRelease nao #ln -s nao/yocto/meta-hulks meta-hulks #sed -i 's|path: \"patches|path: \"yocto/meta-hulks/patches|' meta-hulks/kas-project.yml cp -r nao/yocto/meta-hulks meta-hulks git clone git@github.com:HULKs/meta-nao During the HULKs code release generation, some cryptographic keys are replaced. If you want to e.g. connect to a NAO via SSH the following steps need to be done to recreate the keys: # working directory is still `yocto` ssh-keygen -t ed25519 -C nao@hulk -f nao/scripts/ssh_key # Answer `y` when asked to overwrite cat nao/scripts/ssh_key.pub > meta-hulks/recipes-connectivity/openssh/openssh/authorized_keys If you wondered, as a non HULKs member you don't need the meta-hulks/ssh-dir populated with keys. In addition to the SSH keys, also the NAO hardware IDs and wireless network configurations need to be adjusted. The hardware IDs can be configured in meta-hulks/recipes-hulks/network-config/network-config/id_map.json . Wireless networks can be configured at meta-hulks/recipes-conf/nao-wifi-conf/nao-wifi-conf/*.psk ( iwd is used). If networks are added/removed or names change, the recipe meta-hulks/recipes-conf/nao-wifi-conf.bb also needs adjustmenst. For project setup the siemens/kas framework is used. To setup kas use the containerized version (podman or docker) via the kas-container script and store it inside the yocto directory. wget https://github.com/siemens/kas/raw/master/kas-container chmod +x kas-container Alternatively setup kas via a python-pip installation, follow the installation steps in the user guide . The meta-hulks layer ships a kas-project.yml project description file. This file defines the project structure kas has to setup for the Yocto build phase. The next step is to download all the referenced repositories in the kas-project.yml . ./kas-container checkout meta-hulks/kas-project.yml The NAO v6 uses LoLA and HAL for communication with the chestboard. All these binaries and libraries necessary to operate the NAO properly are shipped with the .opn RoboCupper image and are not included in this repository. For HULKs members contact our dev-leads and for non HULKs members contact the RoboCup SPL Technical Committee to get this image. To extract the necessary binaries the extract_binaries.sh script is used. This script fetches all binaries from inside the RoboCupper image and collects them in an archive for the upcoming build phase. To generate the archive containing the aldebaran binaries run (with root privileges): cd meta-nao/recipes-support/aldebaran/ mkdir -p aldebaran-binaries ./extract_binaries.sh -o aldebaran-binaries/aldebaran_binaries.tar.gz nao-2.8.5.11_ROBOCUP_ONLY_with_root.opn Starting a Build Shell kas is able to start a shell inside of the build environment. The kas-project.yml of meta-hulks needs to be referenced: # working directory is `yocto` ./kas-container shell meta-hulks/kas-project.yml All BitBake and Devtool commands shall be executed from this shell. Preparing the Build The NAO image contains the HULA binary (TODO: link to HULA) which is built from HULKs/nao or HULKs/CodeRelease (depending on whether you are a HULKs member or not). The HULA source code is located in tools/hula . The meta-hulks layer is set up to clone the private HULKs/nao repository and check out a specific version. This only works if the kas-container has SSH correctly set up and uses a SSH key that has access to the repository. Ensure that the SSH private key has appropriate permissions, usually 600 . Most often it is easier to clone the repository manually and point BitBake to use it. The following command can be executed within the build environment to do that: devtool modify --no-extract hula /work/nao This must be executed at any restart of the build shell. Building the Image Inside of the build shell, the following command will build the NAO image. The initial build may take multiple hours depending on your hardware and internet access. BitBake provides advanced caching of the build artifacts which means that future builds are done in minutes depending on the changes. The cache relies in the build/sstate-cache which can be copied from another build directory or shared between machines ( see Yocto Documentation about Shared State Cache ). To build the image run the following command in the build shell: bitbake nao-image This generates and executes all necessary tasks and targets to construct a proper .opn file. The initial build phase might take several hours depending on the performance of your build machine and your internet connection. BitBake uses a very elaborated caching strategy to speed up following builds of targets. Thus small changes afterwards might only take a few minutes. As soon as the build has successfully finished, the image can be deployed. After BitBake ran all tasks up to nao-image, a new .opn file is generated in build/tmp/deploy/images/nao-v6/nao-image-HULKs-OS-[...].ext3.gz.opn . The image can now be flashed to a USB flash drive: dd if = nao-image-HULKs-OS- [ ... ] .ext3.gz.opn.opn of = /dev/sdb status = progress sync A RoboCupper image needs to be flashed first because the Yocto .opn does not flash the chestboard (which needs up-to-date software). Now flash the NAO with the Yocto image. The flashing process may take 1-3 minutes. It is finished if the HULA process displays a red LED animation in the eyes. Building the SDK To be able to compile the HULKs robotics code targeting the NAO platform, the code needs to be cross compiled for the NAO target. Within the build shell, the following command will build the SDK: bitbake -c populate_sdk nao-image This build phase may take several hours. After a successful build, the SDK is located at build/tmp/deploy/sdk/HULKs-OS-toolchain-[...].sh . To install the SDK run the script and follow the instructions. Afterwards, you are able to source the build environment and use the respective cross compilers. Advanced: Upgrade other Yocto Layers The Yocto Project and the Poky reference distribution provide a Linux kernel, userland programs, libraries, and other tooling. All these things are updated in the regular Yocto releases. To ensure deterministic builds the HULKs freeze versions of all used layers in the kas-project.yml files of meta-nao and meta-hulks. Advanced: Upgrade Image/SDK Versions and Semantic Versioning The HULKs use semantic versioning for the Yocto images and SDKs. This means that versions are increased depending on the severity of changes. The following policy exists for the HULKs: Images have major, minor, and patch version numbers (e.g. 4.2.3), SDKs have only have major and minor (e.g. 4.2) Same version numbers of images and SDKs are compatible to each other Major changes, refactorings, implementations result in the increase of the major version number Minor changes, additions and iterations result in the increase of the minor version number Changes in the image that do not require SDK recreation, result in the increase of the patch version number (which only requires to create a new image) Before building new images, the version number needs to be set in meta-hulks/conf/distro/HULKsOS.conf . Only change the DISTRO_VERSION , the SDK_VERSION is automatically derived from the DISTRO_VERSION . Once new SDKs are deployed at the BigHULKs for HULKs members or in the local downloads directory sdk/downloads in the HULKs repository for non HULKs members, the Pepsi tool needs to learn to use the new SDK. Therefore update the version in crates/repository/src/lib.rs in the variable SDK_VERSION . Successive builds with Pepsi will use the new version. Advanced: Upgrade Rust Version Since upgrading the Rust version often requires manual steps, this section describes the approach on how to upgrade and generate the needed patch files. These instructions can be followed e.g. if a new Rust version is available and a new image/SDK should be created with this new version. Users that just want to use the current version that we upgraded to should skip this section. The latest patch set for is included in the meta-hulks layer (in patches/ ) or HULKs code release (in yocto/meta-hulks/patches/ ). Rust is provided by the poky repository. The recipes are located in meta/recipes-devtools/{cargo,rust} . The following steps are high-level instructions on how to modify the poky repository. A patch file can be created after applying these instructions and saved to the corresponding meta-hulks layer. Set new version in the RUSTVERSION variable in poky/meta/conf/distro/include/tcmode-default.inc Rename files (to new version) in poky/meta/recipes-devtools/cargo/ Rename files (to new version) in poky/meta/recipes-devtools/rust/ Some LLVM benchmarks are built and run during the compilation which often results in errors. Therefore, it is a good idea to just exclude them by appending -DLLVM_BUILD_BENCHMARKS=OFF and -DLLVM_INCLUDE_BENCHMARKS=OFF to the EXTRA_OECMAKE variable in poky/meta/recipes-devtools/rust/rust-llvm.inc . Set new version in the RS_VERSION and CARGO_VERSION variable in poky/meta/recipes-devtools/rust/rust-snapshot.inc Update the checksums in poky/meta/recipes-devtools/rust/rust-snapshot.inc for the NAO architecture x86_64 Download the files in your command line (example for Rust version 1.63): RS_VERSION = \"1.63.0\" CARGO_VERSION = \"1.63.0\" RUST_BUILD_ARCH = \"x86_64\" RUST_STD_SNAPSHOT = \"rust-std- ${ RS_VERSION } - ${ RUST_BUILD_ARCH } -unknown-linux-gnu\" RUSTC_SNAPSHOT = \"rustc- ${ RS_VERSION } - ${ RUST_BUILD_ARCH } -unknown-linux-gnu\" CARGO_SNAPSHOT = \"cargo- ${ CARGO_VERSION } - ${ RUST_BUILD_ARCH } -unknown-linux-gnu\" wget \"https://static.rust-lang.org/dist/ ${ RUST_STD_SNAPSHOT } .tar.xz\" wget \"https://static.rust-lang.org/dist/ ${ RUSTC_SNAPSHOT } .tar.xz\" wget \"https://static.rust-lang.org/dist/ ${ CARGO_SNAPSHOT } .tar.xz\" Generate the checksums in the same terminal: sha256sum ${ RUST_STD_SNAPSHOT } .tar.xz ${ RUSTC_SNAPSHOT } .tar.xz ${ CARGO_SNAPSHOT } .tar.xz Keep the terminal open for the next step Update the checksums in poky/meta/recipes-devtools/rust/rust-source.inc Download the files: wget \"https://static.rust-lang.org/dist/rustc- ${ RS_VERSION } -src.tar.xz\" Generate the checksums in the same terminal: sha256sum \"rustc- ${ RS_VERSION } -src.tar.xz\" Run bitbake nao-image within the build shell Errors similar to libstd-rs-1.63.0-r0 do_patch: Applying patch... often mean that patches are obsolete. These patches are located in poky/meta/recipes-devtools/rust/libstd-rs/ and poky/meta/recipes-devtools/rust/rust-llvm/ . Deleted patches need to be removed from their corresponding recipes. Afterwards rerun the image build. Once a successful build completed, create a patch from the changes in poky: sh cd poky/ git add . git commit # ... git format-patch HEAD~ # this generates 0001-....patch Copy the patch file into meta-hulks/patches/0001....patch and fix the patch path in meta-hulks/kas-project.yml","title":"NAO Image & SDK"},{"location":"setup/nao_image_and_sdk/#nao-image-sdk","text":"TODO: decide whether to backtick all \"meta-nao\", \"meta-hulks\", \"kas\", \"BitBake\" names TODO: \"code release\" or \"code-release\" or \"coderelease\"? TODO: Set up id map json first TODO: Change team number in meta-hulks The HULKs use the Yocto Project for creating flashable OPN images for the NAO and a corresponding software development kit (SDK) for local development targeting the NAO. The SDK contains a full cross-compilation toolchain that is self-contained and can be easily used on development machines.","title":"NAO Image &amp; SDK"},{"location":"setup/nao_image_and_sdk/#use-an-existing-yocto-sdk-with-the-hulks-code","text":"HULKs Members Non HULKs Members HULKs members can just use the Pepsi tool (TODO: link to Pepsi) to compile and upload to a booted NAO. This needs to be done in the lab or with VPN access to the BigHULK. Within the HULKs repository, use the following command to e.g. upload to NAO 42: ./pepsi upload 42 You will be asked to install the SDK during the compilation process. Just choose the defaults if unsure or ask your fellow HULK. Non HULKs members need to copy the Yocto SDK to the local downloads folder to prevent the Pepsi tool (TODO: link to Pepsi) from downloading it during compilation. For instructions on how to build the image and SDK refer to the section Image & SDK Creation . mkdir -p sdk/downloads/ cp .../HULKs-OS-toolchain- [ ... ] .sh sdk/downloads/ ./pepsi upload 42 You will be asked to install the SDK during the compilation process. Just choose the defaults if unsure.","title":"Use an Existing Yocto SDK with the HULKs Code"},{"location":"setup/nao_image_and_sdk/#image-sdk-creation","text":"The Yocto Project leverages BitBake as task execution engine and offers an abstraction layer to modify and extend existing build configurations. Combined with OpenEmbedded , the entire worktree is structured in several layers (the HULKs use the meta-nao and meta-hulks layers).","title":"Image &amp; SDK Creation"},{"location":"setup/nao_image_and_sdk/#setup-of-the-working-directory","text":"For creating the image and SDK, make sure there is at least 100 GB empty disk space available. Start by cloning the code (if not done before) and setting up a Yocto working directory. This working directory will contain the layers HULKs/meta-nao and meta-hulks, a script for running BitBake commands, and the HULKs nao repository. It will be called yocto . The new yocto working directory must have at least 100 GB of empty space available and should not be part of a Git repository. mkdir yocto/ cd yocto/ HULKs Members Non HULKs Members HULKs members need the HULKs/nao repository, and the HULKs/meta-nao and HULKs/meta-hulks layer. The rest should already be set up. # working directory is still `yocto` git clone git@github.com:HULKs/nao git clone git@github.com:HULKs/meta-nao git clone git@github.com:HULKs/meta-hulks Non HULKs members need the HULKs/meta-nao layer and the meta-hulks layer from HULKs/CodeRelease (in the subdirectory yocto/meta-hulks ). # working directory is still `yocto` git clone git@github.com:HULKs/HULKsCodeRelease mv HULKsCodeRelease nao #ln -s nao/yocto/meta-hulks meta-hulks #sed -i 's|path: \"patches|path: \"yocto/meta-hulks/patches|' meta-hulks/kas-project.yml cp -r nao/yocto/meta-hulks meta-hulks git clone git@github.com:HULKs/meta-nao During the HULKs code release generation, some cryptographic keys are replaced. If you want to e.g. connect to a NAO via SSH the following steps need to be done to recreate the keys: # working directory is still `yocto` ssh-keygen -t ed25519 -C nao@hulk -f nao/scripts/ssh_key # Answer `y` when asked to overwrite cat nao/scripts/ssh_key.pub > meta-hulks/recipes-connectivity/openssh/openssh/authorized_keys If you wondered, as a non HULKs member you don't need the meta-hulks/ssh-dir populated with keys. In addition to the SSH keys, also the NAO hardware IDs and wireless network configurations need to be adjusted. The hardware IDs can be configured in meta-hulks/recipes-hulks/network-config/network-config/id_map.json . Wireless networks can be configured at meta-hulks/recipes-conf/nao-wifi-conf/nao-wifi-conf/*.psk ( iwd is used). If networks are added/removed or names change, the recipe meta-hulks/recipes-conf/nao-wifi-conf.bb also needs adjustmenst. For project setup the siemens/kas framework is used. To setup kas use the containerized version (podman or docker) via the kas-container script and store it inside the yocto directory. wget https://github.com/siemens/kas/raw/master/kas-container chmod +x kas-container Alternatively setup kas via a python-pip installation, follow the installation steps in the user guide . The meta-hulks layer ships a kas-project.yml project description file. This file defines the project structure kas has to setup for the Yocto build phase. The next step is to download all the referenced repositories in the kas-project.yml . ./kas-container checkout meta-hulks/kas-project.yml The NAO v6 uses LoLA and HAL for communication with the chestboard. All these binaries and libraries necessary to operate the NAO properly are shipped with the .opn RoboCupper image and are not included in this repository. For HULKs members contact our dev-leads and for non HULKs members contact the RoboCup SPL Technical Committee to get this image. To extract the necessary binaries the extract_binaries.sh script is used. This script fetches all binaries from inside the RoboCupper image and collects them in an archive for the upcoming build phase. To generate the archive containing the aldebaran binaries run (with root privileges): cd meta-nao/recipes-support/aldebaran/ mkdir -p aldebaran-binaries ./extract_binaries.sh -o aldebaran-binaries/aldebaran_binaries.tar.gz nao-2.8.5.11_ROBOCUP_ONLY_with_root.opn","title":"Setup of the Working Directory"},{"location":"setup/nao_image_and_sdk/#starting-a-build-shell","text":"kas is able to start a shell inside of the build environment. The kas-project.yml of meta-hulks needs to be referenced: # working directory is `yocto` ./kas-container shell meta-hulks/kas-project.yml All BitBake and Devtool commands shall be executed from this shell.","title":"Starting a Build Shell"},{"location":"setup/nao_image_and_sdk/#preparing-the-build","text":"The NAO image contains the HULA binary (TODO: link to HULA) which is built from HULKs/nao or HULKs/CodeRelease (depending on whether you are a HULKs member or not). The HULA source code is located in tools/hula . The meta-hulks layer is set up to clone the private HULKs/nao repository and check out a specific version. This only works if the kas-container has SSH correctly set up and uses a SSH key that has access to the repository. Ensure that the SSH private key has appropriate permissions, usually 600 . Most often it is easier to clone the repository manually and point BitBake to use it. The following command can be executed within the build environment to do that: devtool modify --no-extract hula /work/nao This must be executed at any restart of the build shell.","title":"Preparing the Build"},{"location":"setup/nao_image_and_sdk/#building-the-image","text":"Inside of the build shell, the following command will build the NAO image. The initial build may take multiple hours depending on your hardware and internet access. BitBake provides advanced caching of the build artifacts which means that future builds are done in minutes depending on the changes. The cache relies in the build/sstate-cache which can be copied from another build directory or shared between machines ( see Yocto Documentation about Shared State Cache ). To build the image run the following command in the build shell: bitbake nao-image This generates and executes all necessary tasks and targets to construct a proper .opn file. The initial build phase might take several hours depending on the performance of your build machine and your internet connection. BitBake uses a very elaborated caching strategy to speed up following builds of targets. Thus small changes afterwards might only take a few minutes. As soon as the build has successfully finished, the image can be deployed. After BitBake ran all tasks up to nao-image, a new .opn file is generated in build/tmp/deploy/images/nao-v6/nao-image-HULKs-OS-[...].ext3.gz.opn . The image can now be flashed to a USB flash drive: dd if = nao-image-HULKs-OS- [ ... ] .ext3.gz.opn.opn of = /dev/sdb status = progress sync A RoboCupper image needs to be flashed first because the Yocto .opn does not flash the chestboard (which needs up-to-date software). Now flash the NAO with the Yocto image. The flashing process may take 1-3 minutes. It is finished if the HULA process displays a red LED animation in the eyes.","title":"Building the Image"},{"location":"setup/nao_image_and_sdk/#building-the-sdk","text":"To be able to compile the HULKs robotics code targeting the NAO platform, the code needs to be cross compiled for the NAO target. Within the build shell, the following command will build the SDK: bitbake -c populate_sdk nao-image This build phase may take several hours. After a successful build, the SDK is located at build/tmp/deploy/sdk/HULKs-OS-toolchain-[...].sh . To install the SDK run the script and follow the instructions. Afterwards, you are able to source the build environment and use the respective cross compilers.","title":"Building the SDK"},{"location":"setup/nao_image_and_sdk/#advanced-upgrade-other-yocto-layers","text":"The Yocto Project and the Poky reference distribution provide a Linux kernel, userland programs, libraries, and other tooling. All these things are updated in the regular Yocto releases. To ensure deterministic builds the HULKs freeze versions of all used layers in the kas-project.yml files of meta-nao and meta-hulks.","title":"Advanced: Upgrade other Yocto Layers"},{"location":"setup/nao_image_and_sdk/#advanced-upgrade-imagesdk-versions-and-semantic-versioning","text":"The HULKs use semantic versioning for the Yocto images and SDKs. This means that versions are increased depending on the severity of changes. The following policy exists for the HULKs: Images have major, minor, and patch version numbers (e.g. 4.2.3), SDKs have only have major and minor (e.g. 4.2) Same version numbers of images and SDKs are compatible to each other Major changes, refactorings, implementations result in the increase of the major version number Minor changes, additions and iterations result in the increase of the minor version number Changes in the image that do not require SDK recreation, result in the increase of the patch version number (which only requires to create a new image) Before building new images, the version number needs to be set in meta-hulks/conf/distro/HULKsOS.conf . Only change the DISTRO_VERSION , the SDK_VERSION is automatically derived from the DISTRO_VERSION . Once new SDKs are deployed at the BigHULKs for HULKs members or in the local downloads directory sdk/downloads in the HULKs repository for non HULKs members, the Pepsi tool needs to learn to use the new SDK. Therefore update the version in crates/repository/src/lib.rs in the variable SDK_VERSION . Successive builds with Pepsi will use the new version.","title":"Advanced: Upgrade Image/SDK Versions and Semantic Versioning"},{"location":"setup/nao_image_and_sdk/#advanced-upgrade-rust-version","text":"Since upgrading the Rust version often requires manual steps, this section describes the approach on how to upgrade and generate the needed patch files. These instructions can be followed e.g. if a new Rust version is available and a new image/SDK should be created with this new version. Users that just want to use the current version that we upgraded to should skip this section. The latest patch set for is included in the meta-hulks layer (in patches/ ) or HULKs code release (in yocto/meta-hulks/patches/ ). Rust is provided by the poky repository. The recipes are located in meta/recipes-devtools/{cargo,rust} . The following steps are high-level instructions on how to modify the poky repository. A patch file can be created after applying these instructions and saved to the corresponding meta-hulks layer. Set new version in the RUSTVERSION variable in poky/meta/conf/distro/include/tcmode-default.inc Rename files (to new version) in poky/meta/recipes-devtools/cargo/ Rename files (to new version) in poky/meta/recipes-devtools/rust/ Some LLVM benchmarks are built and run during the compilation which often results in errors. Therefore, it is a good idea to just exclude them by appending -DLLVM_BUILD_BENCHMARKS=OFF and -DLLVM_INCLUDE_BENCHMARKS=OFF to the EXTRA_OECMAKE variable in poky/meta/recipes-devtools/rust/rust-llvm.inc . Set new version in the RS_VERSION and CARGO_VERSION variable in poky/meta/recipes-devtools/rust/rust-snapshot.inc Update the checksums in poky/meta/recipes-devtools/rust/rust-snapshot.inc for the NAO architecture x86_64 Download the files in your command line (example for Rust version 1.63): RS_VERSION = \"1.63.0\" CARGO_VERSION = \"1.63.0\" RUST_BUILD_ARCH = \"x86_64\" RUST_STD_SNAPSHOT = \"rust-std- ${ RS_VERSION } - ${ RUST_BUILD_ARCH } -unknown-linux-gnu\" RUSTC_SNAPSHOT = \"rustc- ${ RS_VERSION } - ${ RUST_BUILD_ARCH } -unknown-linux-gnu\" CARGO_SNAPSHOT = \"cargo- ${ CARGO_VERSION } - ${ RUST_BUILD_ARCH } -unknown-linux-gnu\" wget \"https://static.rust-lang.org/dist/ ${ RUST_STD_SNAPSHOT } .tar.xz\" wget \"https://static.rust-lang.org/dist/ ${ RUSTC_SNAPSHOT } .tar.xz\" wget \"https://static.rust-lang.org/dist/ ${ CARGO_SNAPSHOT } .tar.xz\" Generate the checksums in the same terminal: sha256sum ${ RUST_STD_SNAPSHOT } .tar.xz ${ RUSTC_SNAPSHOT } .tar.xz ${ CARGO_SNAPSHOT } .tar.xz Keep the terminal open for the next step Update the checksums in poky/meta/recipes-devtools/rust/rust-source.inc Download the files: wget \"https://static.rust-lang.org/dist/rustc- ${ RS_VERSION } -src.tar.xz\" Generate the checksums in the same terminal: sha256sum \"rustc- ${ RS_VERSION } -src.tar.xz\" Run bitbake nao-image within the build shell Errors similar to libstd-rs-1.63.0-r0 do_patch: Applying patch... often mean that patches are obsolete. These patches are located in poky/meta/recipes-devtools/rust/libstd-rs/ and poky/meta/recipes-devtools/rust/rust-llvm/ . Deleted patches need to be removed from their corresponding recipes. Afterwards rerun the image build. Once a successful build completed, create a patch from the changes in poky: sh cd poky/ git add . git commit # ... git format-patch HEAD~ # this generates 0001-....patch Copy the patch file into meta-hulks/patches/0001....patch and fix the patch path in meta-hulks/kas-project.yml","title":"Advanced: Upgrade Rust Version"},{"location":"setup/nao_setup/","text":"NAO Setup This section assumes you have a working SDK installed. See Nao Image and SDK to learn how to acquire or build one. Configuring Team Specific Data HULKs Members Non HULKs Members There is nothing to do, all the configuration should be ready to if you cloned the hulks/nao repository. SSH Keys If you built your own SDK, you should have created an SSH key pair. The public key is used during image creation and registered as an authorized key in the openssh configuration. All of our tools expect the private key to be located at scripts/ssh_key . If you did not create the SDK yourself, ask your teammates for the key. Set up Team Number In the HULKs code release, the SPL team number is hardcoded in a few places. Change this to your own team number before continuing. crates/spl_network/src/lib.rs contains a constant called HULKS_TEAM_NUMBER. You may also wish to rename this constant. tools/pepsi contains a bunch of 24 s, however most of them are in comments or CLI command help text. tools/pepsi/src/parsers.rs has a default and a check value that use 24 literals. tools/twix/src/completion_edit.rs generates IP address suggestions with a hardcoded team number. Set up Hardware IDs The tooling around our framework expects each NAO robot to have a number associated with it's hardware IDs. This number also determines the last octet of a robot's IP addresses. For example robot number 21 will always have the IPv4 addresses 10.0.X.21 (wireless) and 10.1.X.21 (ethernet) where X is the team number. For each robot you must determine it's head and body IDs and enter them in etc/configuration/hardware_ids.json . This file is used by pepsi and other tools to find the hardware ids belonging to a robot number. Flashing the Firmware Preparing a Flash-Stick First, the firmware image has to be flashed to a USB stick. Use lsblk to make sure you are overwriting the correct device. lsblk All existing data on the target device will be wiped! Replace sdX with the USB device. dd if = path-to-nao-image.opn of = /dev/sdX status = progress Finally, run sync to make sure all data has actually been written to the stick before unplugging it. sync Flashing the NAO Make sure the robot is turned off and a charger is plugged in to prevent a sudden loss of power during the process. Plug the prepared USB stick into the back of the NAO's head. Hold the chest button for about 5 seconds until it starts glowing, then release immediately. The chest button LED should now be flashing rapidly. Wait for the flashing process to finish The new firmare should be installed now. Compiling for NAO ./pepsi build --target nao will compile the code for use on the NAO with the incremental cargo profile. Uploading to the NAO ./pepsi upload <number> will first compile the code with the same incremental cargo profile and the upload the binary and configuration files to the robot with the specified number. Remote Shell Access ./pepsi shell <number> establishes an SSH connection and presents an interactive shell to the user.","title":"NAO Setup"},{"location":"setup/nao_setup/#nao-setup","text":"This section assumes you have a working SDK installed. See Nao Image and SDK to learn how to acquire or build one.","title":"NAO Setup"},{"location":"setup/nao_setup/#configuring-team-specific-data","text":"HULKs Members Non HULKs Members There is nothing to do, all the configuration should be ready to if you cloned the hulks/nao repository.","title":"Configuring Team Specific Data"},{"location":"setup/nao_setup/#ssh-keys","text":"If you built your own SDK, you should have created an SSH key pair. The public key is used during image creation and registered as an authorized key in the openssh configuration. All of our tools expect the private key to be located at scripts/ssh_key . If you did not create the SDK yourself, ask your teammates for the key.","title":"SSH Keys"},{"location":"setup/nao_setup/#set-up-team-number","text":"In the HULKs code release, the SPL team number is hardcoded in a few places. Change this to your own team number before continuing. crates/spl_network/src/lib.rs contains a constant called HULKS_TEAM_NUMBER. You may also wish to rename this constant. tools/pepsi contains a bunch of 24 s, however most of them are in comments or CLI command help text. tools/pepsi/src/parsers.rs has a default and a check value that use 24 literals. tools/twix/src/completion_edit.rs generates IP address suggestions with a hardcoded team number.","title":"Set up Team Number"},{"location":"setup/nao_setup/#set-up-hardware-ids","text":"The tooling around our framework expects each NAO robot to have a number associated with it's hardware IDs. This number also determines the last octet of a robot's IP addresses. For example robot number 21 will always have the IPv4 addresses 10.0.X.21 (wireless) and 10.1.X.21 (ethernet) where X is the team number. For each robot you must determine it's head and body IDs and enter them in etc/configuration/hardware_ids.json . This file is used by pepsi and other tools to find the hardware ids belonging to a robot number.","title":"Set up Hardware IDs"},{"location":"setup/nao_setup/#flashing-the-firmware","text":"","title":"Flashing the Firmware"},{"location":"setup/nao_setup/#preparing-a-flash-stick","text":"First, the firmware image has to be flashed to a USB stick. Use lsblk to make sure you are overwriting the correct device. lsblk All existing data on the target device will be wiped! Replace sdX with the USB device. dd if = path-to-nao-image.opn of = /dev/sdX status = progress Finally, run sync to make sure all data has actually been written to the stick before unplugging it. sync","title":"Preparing a Flash-Stick"},{"location":"setup/nao_setup/#flashing-the-nao","text":"Make sure the robot is turned off and a charger is plugged in to prevent a sudden loss of power during the process. Plug the prepared USB stick into the back of the NAO's head. Hold the chest button for about 5 seconds until it starts glowing, then release immediately. The chest button LED should now be flashing rapidly. Wait for the flashing process to finish The new firmare should be installed now.","title":"Flashing the NAO"},{"location":"setup/nao_setup/#compiling-for-nao","text":"./pepsi build --target nao will compile the code for use on the NAO with the incremental cargo profile.","title":"Compiling for NAO"},{"location":"setup/nao_setup/#uploading-to-the-nao","text":"./pepsi upload <number> will first compile the code with the same incremental cargo profile and the upload the binary and configuration files to the robot with the specified number.","title":"Uploading to the NAO"},{"location":"setup/nao_setup/#remote-shell-access","text":"./pepsi shell <number> establishes an SSH connection and presents an interactive shell to the user.","title":"Remote Shell Access"},{"location":"setup/overview/","text":"Overview TODO: Symbolbild HULK mit pepsi This section describes the necessary steps to download the code, compile for the Webots simulator, how to prepare the NAO SDK and image using Yocto and finally how to compile and upload the software to a real NAO robot.","title":"Overview"},{"location":"setup/overview/#overview","text":"TODO: Symbolbild HULK mit pepsi This section describes the necessary steps to download the code, compile for the Webots simulator, how to prepare the NAO SDK and image using Yocto and finally how to compile and upload the software to a real NAO robot.","title":"Overview"},{"location":"tooling/debugging/","text":"","title":"Debugging with GDB/LLDB"},{"location":"tooling/depp/","text":"","title":"Depp"},{"location":"tooling/fanta/","text":"","title":"Fanta"},{"location":"tooling/machine-learning/","text":"","title":"Machine Learning"},{"location":"tooling/overview/","text":"Overview Apart from the NAO code our repository contains several tools to aid in the development and testing process: Pepsi : A multi-tool to automate repetitive tasks like compiling and deployment Twix : Our debugging tool to visualize live data from the NAO or a Webots simulation Depp : TODO: Irgendwas mit dependencies Fanta : TODO: Irgendwas mit live data auf der CLI Machine Learning : Our tooling to create datasets and neural networks Behavior Simulator : The simulator and viewer to debug and automatically test behavior Debugging with GDB/LLDB : How to use a debugger with our software","title":"Overview"},{"location":"tooling/overview/#overview","text":"Apart from the NAO code our repository contains several tools to aid in the development and testing process: Pepsi : A multi-tool to automate repetitive tasks like compiling and deployment Twix : Our debugging tool to visualize live data from the NAO or a Webots simulation Depp : TODO: Irgendwas mit dependencies Fanta : TODO: Irgendwas mit live data auf der CLI Machine Learning : Our tooling to create datasets and neural networks Behavior Simulator : The simulator and viewer to debug and automatically test behavior Debugging with GDB/LLDB : How to use a debugger with our software","title":"Overview"},{"location":"tooling/pepsi/","text":"Pepsi Pepsi is a multi-tool we use for anything related to the code or the NAO robots. It can be used to build the code, set up configuration for a game, deploy to a robot or simply open a remote shell. This page is only meant as a general overview of pepsi's subcommands. For detailed usage instructions, run pepsi --help or pepsi <subcommand> --help . Typical Webots Workflow This is pretty simple. Open Webots, load the webots/worlds/penalized_extern.wbt world file and execute ./pepsi run in your terminal. This will build (if necessary) and then run the webots binary. The simulation is paused automatically until the binary starts. Typical NAO Workflow ./pepsi upload <number or IP> This command does the following: checks if a toolchain is installed, downloads, and installs one if necessary builds the code for the NAO target uploads binary, configuration, motion files, neural networks, etc. to the NAO(s) restarts HULK service on the NAO(s) Interaction with the NAO NAOs are identified either by IP or by number. Numbers are converted to IPs as follows: {number} -> 10.1.24.{number} {number}w -> 10.0.24.{number} Many subcommands can act on multiple robots concurrently. upload builds a binary for the NAO target, and then uploads it and configuration files to one or more robot. wireless , reboot , poweroff , and hulk directly interact with the robot(s), whereas communication , and playernumber only change the local configuration. pregame combines deactivating aliveness & communication (to avoid sending illegal messages), assigning playernumbers, setting a wifi network, uploading, and restarting the HULK service. logs or and postgame can be used after a (test-)game to download logs, the latter also shuts down the HULKs binary and disables wifi. Build Options For subcommands that build a binary, you can specify a target and a build profile. These include build , run , check , and clippy . However upload and pregame only supports a profiles, since it doesn't make sense to upload a webots binary to the nao. Shell Completion Shell completions can be generated using the completions subcommand. Example: ./pepsi completions zsh > _pepsi Refer to your shell's completion documentation for details.","title":"Pepsi"},{"location":"tooling/pepsi/#pepsi","text":"Pepsi is a multi-tool we use for anything related to the code or the NAO robots. It can be used to build the code, set up configuration for a game, deploy to a robot or simply open a remote shell. This page is only meant as a general overview of pepsi's subcommands. For detailed usage instructions, run pepsi --help or pepsi <subcommand> --help .","title":"Pepsi"},{"location":"tooling/pepsi/#typical-webots-workflow","text":"This is pretty simple. Open Webots, load the webots/worlds/penalized_extern.wbt world file and execute ./pepsi run in your terminal. This will build (if necessary) and then run the webots binary. The simulation is paused automatically until the binary starts.","title":"Typical Webots Workflow"},{"location":"tooling/pepsi/#typical-nao-workflow","text":"./pepsi upload <number or IP> This command does the following: checks if a toolchain is installed, downloads, and installs one if necessary builds the code for the NAO target uploads binary, configuration, motion files, neural networks, etc. to the NAO(s) restarts HULK service on the NAO(s)","title":"Typical NAO Workflow"},{"location":"tooling/pepsi/#interaction-with-the-nao","text":"NAOs are identified either by IP or by number. Numbers are converted to IPs as follows: {number} -> 10.1.24.{number} {number}w -> 10.0.24.{number} Many subcommands can act on multiple robots concurrently. upload builds a binary for the NAO target, and then uploads it and configuration files to one or more robot. wireless , reboot , poweroff , and hulk directly interact with the robot(s), whereas communication , and playernumber only change the local configuration. pregame combines deactivating aliveness & communication (to avoid sending illegal messages), assigning playernumbers, setting a wifi network, uploading, and restarting the HULK service. logs or and postgame can be used after a (test-)game to download logs, the latter also shuts down the HULKs binary and disables wifi.","title":"Interaction with the NAO"},{"location":"tooling/pepsi/#build-options","text":"For subcommands that build a binary, you can specify a target and a build profile. These include build , run , check , and clippy . However upload and pregame only supports a profiles, since it doesn't make sense to upload a webots binary to the nao.","title":"Build Options"},{"location":"tooling/pepsi/#shell-completion","text":"Shell completions can be generated using the completions subcommand. Example: ./pepsi completions zsh > _pepsi Refer to your shell's completion documentation for details.","title":"Shell Completion"},{"location":"tooling/sprite/","text":"","title":"Behavior-Simulator & Sprite"},{"location":"tooling/twix/","text":"","title":"Twix"},{"location":"workflow/competition/","text":"Competition TODO Meetings TODO Roles TODO","title":"Competition"},{"location":"workflow/competition/#competition","text":"TODO","title":"Competition"},{"location":"workflow/competition/#meetings","text":"TODO","title":"Meetings"},{"location":"workflow/competition/#roles","text":"TODO","title":"Roles"},{"location":"workflow/development/","text":"Development TODO GitHub TODO CI TODO Board TODO Meetings TODO Test Games TODO Test-driven development TODO Unit testing TODO Webots TODO Behavior Simulator TODO","title":"Development"},{"location":"workflow/development/#development","text":"TODO","title":"Development"},{"location":"workflow/development/#github","text":"TODO","title":"GitHub"},{"location":"workflow/development/#ci","text":"TODO","title":"CI"},{"location":"workflow/development/#board","text":"TODO","title":"Board"},{"location":"workflow/development/#meetings","text":"TODO","title":"Meetings"},{"location":"workflow/development/#test-games","text":"TODO","title":"Test Games"},{"location":"workflow/development/#test-driven-development","text":"TODO","title":"Test-driven development"},{"location":"workflow/development/#unit-testing","text":"TODO","title":"Unit testing"},{"location":"workflow/development/#webots","text":"TODO","title":"Webots"},{"location":"workflow/development/#behavior-simulator","text":"TODO","title":"Behavior Simulator"},{"location":"workflow/overview/","text":"Overview TODO: Elaborate Development workflow GitHub CI Board Meetings Test games Test-driven development Unit testing Webots Behavior Simulator Competition workflow Meetings Roles","title":"Overview"},{"location":"workflow/overview/#overview","text":"TODO: Elaborate Development workflow GitHub CI Board Meetings Test games Test-driven development Unit testing Webots Behavior Simulator Competition workflow Meetings Roles","title":"Overview"}]}